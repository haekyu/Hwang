## Overview
- Primitive data type
- Series data type
- 기본 연산

## Primitive data type
- Primitive data type 이란 python에서 제공하는 / 정의한 기본 데이터 타입을 말한다.

    |  Type |   설명   |   Example   |
    |:-----:|:--------:|:-----------:|
    |  int  |   정수   |  -10, 0, 32 |
    | float |   소수   |  8.231, 1.0 |
    |  str  | 문자(열) | 'Hi', "123" |
    |  bool |  참/거짓 | True, False |

- int / float 의 연산
    - 사칙연산: +, -, \*, /,
    - \*\*: 승. 제곱
    - %: 나머지
    - //: 몫
    - 예)
        ```python
        # 1 + 2
        In [1]: 1 + 2
        Out[1]: 3

        # 20을 3으로 나눈 나머지
        In [2]: 20 % 3
        Out[2]: 2

        # 20을 3으로 나눈 몫
        In [3]: 20 // 3
        Out[3]: 6

        # 3^(2.0)
        In [4]: 3 ** 2.0
        Out[4]: 9.0
        ```
- str 의 연산
    - +: concatenate. 두 string 을 나란히 붙이기
        - 예)
            ```python
            In [1]: '1' + '2'
            Out[1]: '12'
            ```
    - *: string을 여러 번 붙이기
        - 예)
            ```python
            In [1]: 'abc' * 2
            Out[1]: 'abcabc'
            ```
    - indexing: index 번째의 문자를 가져오는 행위
        - index
            - sequence 내 원소의 위치
            - 번째 를 나타내는 숫자
            - 0 부터 시작
            - 음수 index도 있음
        - 문자열 옆에 대괄호를 열고 닫고, 대괄호 안에 index 를 넣어주면 해당 index의 문자를 읽을 수 있음.
            - 예)
                ```python
                In [1]: 'abc'[0]
                Out[1]: 'a'

                In [2]: 'abc'[-3]
                Out[2]: 'a'
                ```
    - slicing: index **범위**의 문자를 가져오는 행위
        - 범위 표현
            - [from index (이상): to index (미만)] 
            - 범위 표현에 쓰인 index는 생략 가능
        - 예)
            ```python
            # 1번째 원소 'b' 이상부터 3번째 원소 'd' 미만을 가져오기
            In [1]: 'abcdef'[1:3]
            Out[1]: 'bc'

            # (from 생략) -2번째 원소 'e' 미만을 다 가져오기
            In [2]: 'abcdef'[:-2]
            Out[2]: 'abcd'

            # (to 생략) 2번째 원소 'c' 이상을 다 가져오기
            In [3]: 'abcdef'[2:]
            Out[3]: 'cdef'
            ```
    - len(): string의 길이를 가져오는 함수
        - 예)
            ```python
            In [1]: len('abcdef')
            Out[1]: 6
            ```
    - membership: 어떤 문자가 전체 문자열 안에 있는지 / 없는지를 확인하는 연산
        - in: 있는지 확인하는 연산
        - not in: 없는지 확인하는 연산
        - 예)
            ```python
            In [1]: 'a' in 'abc'
            Out[1]: True

            In [2]: 'abc' in 'abc'
            Out[2]: True

            In [3]: 'ba' in 'abc'
            Out[3]: False
            ```
- bool 의 연산
    - 역사적으로 0은 False, 1은 True로 생각한다.
    - not
        - not True == False
        - not False == True
    - and: 교집합, *
        - True and True == True 
        - True and False == False
        - False and True == False
        - False and False == False
    - or: 합집합 +
        - True or True == True  
        - True or False == True
        - False or True == True
        - False or False == False
- 형 변환
    - 데이터 타입을 변환하는 행위
        - 예)
            - 123 -> "123" (int -> str)
            - "123" -> 123 (str -> int)
            - 123 -> 123.0 (int -> float)
            - 123.0 -> 123 (float -> int)
    - 내가 최종적으로 얻고 싶은 데이터 형으로 대상을 덮어 씌워주면 된다.
        - 예)
            ```python
            # int -> str. 결과적으로 str으로 변화시키고 싶으니 input을 str으로 덮어 씌워준다.
            In [1]: str(123)
            Out[1]: '123'

            # str -> int. 결과적으로 int로 변화시키고 싶으니 input을 int로 덮어 씌워준다.
            In [2]: int('123')
            Out[2]: 123

            # int -> float. 결과적으로 float로 변화시키고 싶으니 input을 float로 덮어 씌워준다.
            In [3]: float(123)
            Out[3]: 123.0

            # float -> int. 결과적으로 int로 변화시키고 싶으니 input을 int로 덮어 씌워준다.
            # 버림 효과
            In [4]: int(123.987)
            Out[4]: 123
            ```

## C++ 
- pointer

if 어쩌저쩌고:
    dfs
    sdfsdf
    sdfsdfsd
    fdsf

if (sdfsdfsd){
    sdf
    sdfsdf
    sdfsdf
    sdf
}


## 다음 시간
복잡한 연산
- if else
- loop
- 함수 정의
+ dict


## Series data type
- list
    - type([3, 2, 1])
    - [3, 2, 1, True, 'adcdsfd', [[[[[[[[[[[[[[]]]]]]]]]]]]]]]
    - +
    - *
    - indexing
        - lst = [1, 2, 3]
        - lst[-2] = 0
    - slicing
        - lst[0:2] = [10, 10]
    - membership
        - in
        - not
    - len(lst)
    - append
        - lst.append(10)
    - index
        - lst = [1, 2, 3]
        - lst.index(1)
    - insert
        - lst.insert(인덱스, 값)
        - lst = [1, 2, 3]
        - lst.insert(0, 100)
    - del
        - del lst[?]
        - del lst[:]

    - 
    1 2 3 4
    5 6 7 8
    mat1 = [[1, 2, 3, 4], [5, 6, 7, 8]]

    1 0 0 0
    0 0 0 0
    mat2 = [[1, 0, 0, 0], [0, 0, 0, 0]]

    1 5
    2 6
    3 7
    4 8


- tuple
    - Read-only
    - (1, 2, 3, 4)

- array -> 숫자 연산
    - [1, 2, 3, 4]
    - [1 2 3 4]
        - numpy.array([1, 2, 3, 3])
    - [1, 2, 3, 4] + [1, 1, 1, 1]
    - [1 2 3 4] + [1 1 1 1] = 

    [[1 2 3 4] [5 6 7 'sdf']].T


x = 1
x = 'adfsd'




## 변수
- x = 'abc'
- 변수 이름 = 데이터
- = assign
    - x = x + 'd'
    - x += 'd'
    - i = i + 1
    - i += 1


## 비교 연산자
- ==
    - equal
- !=
- >
- <
- >=
- <=

## String Format
- 2018 6 11
  -> 18/06/11
- 'sfds 변수 fsdf 변수 sdf' % (값, 값)
- 규칙
    - %d: int
    - %f: float
    - %s: string
    - %r: bool
- 복잡한 규칙
    - %03d
    - %.2lf

year = 2018
month = 6
day = 11



박해규



알고리즘 = 함수
- 인풋
- 아웃풋

- 데이터
연산

데이터
- primitive data type
- series data type
- 복잡한 연산 - if , for, while, ..


